# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.26.0
# source: query.sql
import dataclasses
import datetime
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from backend import models


ADD_BATCH = """-- name: add_batch \\:one
INSERT INTO batches (
    reference, sku, purchased_quantity, eta
) VALUES (
    :p1, :p2, :p3, :p4
) RETURNING id, reference, sku, purchased_quantity, eta
"""


ADD_PRODUCT = """-- name: add_product \\:one
INSERT INTO products (
    sku, version_number
) VALUES (
    :p1, :p2
) RETURNING sku, version_number
"""


ALL_BATCHES = """-- name: all_batches \\:many
SELECT id, reference, sku, purchased_quantity, eta
FROM batches
"""


ALL_PRODUCTS = """-- name: all_products \\:many
SELECT products.sku, products.version_number, batches.reference, batches.purchased_quantity, batches.eta
FROM products
LEFT JOIN batches ON products.sku = batches.sku
"""


@dataclasses.dataclass()
class all_productsRow:
    sku: str
    version_number: int
    reference: Optional[str]
    purchased_quantity: Optional[int]
    eta: Optional[datetime.date]


GET_BATCH = """-- name: get_batch \\:one
SELECT id, reference, sku, purchased_quantity, eta
FROM batches
WHERE reference = :p1
"""


GET_PRODUCT = """-- name: get_product \\:many
SELECT products.sku, products.version_number, batches.reference, batches.purchased_quantity, batches.eta
FROM products
LEFT JOIN batches ON products.sku = batches.sku
WHERE products.sku = :p1
"""


@dataclasses.dataclass()
class get_productRow:
    sku: str
    version_number: int
    reference: Optional[str]
    purchased_quantity: Optional[int]
    eta: Optional[datetime.date]


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def add_batch(self, *, reference: Optional[str], sku: str, purchased_quantity: int, eta: Optional[datetime.date]) -> Optional[models.Batch]:
        row = self._conn.execute(sqlalchemy.text(ADD_BATCH), {
            "p1": reference,
            "p2": sku,
            "p3": purchased_quantity,
            "p4": eta,
        }).first()
        if row is None:
            return None
        return models.Batch(
            id=row[0],
            reference=row[1],
            sku=row[2],
            purchased_quantity=row[3],
            eta=row[4],
        )

    def add_product(self, *, sku: str, version_number: int) -> Optional[models.Product]:
        row = self._conn.execute(sqlalchemy.text(ADD_PRODUCT), {"p1": sku, "p2": version_number}).first()
        if row is None:
            return None
        return models.Product(
            sku=row[0],
            version_number=row[1],
        )

    def all_batches(self) -> Iterator[models.Batch]:
        result = self._conn.execute(sqlalchemy.text(ALL_BATCHES))
        for row in result:
            yield models.Batch(
                id=row[0],
                reference=row[1],
                sku=row[2],
                purchased_quantity=row[3],
                eta=row[4],
            )

    def all_products(self) -> Iterator[all_productsRow]:
        result = self._conn.execute(sqlalchemy.text(ALL_PRODUCTS))
        for row in result:
            yield all_productsRow(
                sku=row[0],
                version_number=row[1],
                reference=row[2],
                purchased_quantity=row[3],
                eta=row[4],
            )

    def get_batch(self, *, reference: Optional[str]) -> Optional[models.Batch]:
        row = self._conn.execute(sqlalchemy.text(GET_BATCH), {"p1": reference}).first()
        if row is None:
            return None
        return models.Batch(
            id=row[0],
            reference=row[1],
            sku=row[2],
            purchased_quantity=row[3],
            eta=row[4],
        )

    def get_product(self, *, sku: str) -> Iterator[get_productRow]:
        result = self._conn.execute(sqlalchemy.text(GET_PRODUCT), {"p1": sku})
        for row in result:
            yield get_productRow(
                sku=row[0],
                version_number=row[1],
                reference=row[2],
                purchased_quantity=row[3],
                eta=row[4],
            )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def add_batch(self, *, reference: Optional[str], sku: str, purchased_quantity: int, eta: Optional[datetime.date]) -> Optional[models.Batch]:
        row = (await self._conn.execute(sqlalchemy.text(ADD_BATCH), {
            "p1": reference,
            "p2": sku,
            "p3": purchased_quantity,
            "p4": eta,
        })).first()
        if row is None:
            return None
        return models.Batch(
            id=row[0],
            reference=row[1],
            sku=row[2],
            purchased_quantity=row[3],
            eta=row[4],
        )

    async def add_product(self, *, sku: str, version_number: int) -> Optional[models.Product]:
        row = (await self._conn.execute(sqlalchemy.text(ADD_PRODUCT), {"p1": sku, "p2": version_number})).first()
        if row is None:
            return None
        return models.Product(
            sku=row[0],
            version_number=row[1],
        )

    async def all_batches(self) -> AsyncIterator[models.Batch]:
        result = await self._conn.stream(sqlalchemy.text(ALL_BATCHES))
        async for row in result:
            yield models.Batch(
                id=row[0],
                reference=row[1],
                sku=row[2],
                purchased_quantity=row[3],
                eta=row[4],
            )

    async def all_products(self) -> AsyncIterator[all_productsRow]:
        result = await self._conn.stream(sqlalchemy.text(ALL_PRODUCTS))
        async for row in result:
            yield all_productsRow(
                sku=row[0],
                version_number=row[1],
                reference=row[2],
                purchased_quantity=row[3],
                eta=row[4],
            )

    async def get_batch(self, *, reference: Optional[str]) -> Optional[models.Batch]:
        row = (await self._conn.execute(sqlalchemy.text(GET_BATCH), {"p1": reference})).first()
        if row is None:
            return None
        return models.Batch(
            id=row[0],
            reference=row[1],
            sku=row[2],
            purchased_quantity=row[3],
            eta=row[4],
        )

    async def get_product(self, *, sku: str) -> AsyncIterator[get_productRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_PRODUCT), {"p1": sku})
        async for row in result:
            yield get_productRow(
                sku=row[0],
                version_number=row[1],
                reference=row[2],
                purchased_quantity=row[3],
                eta=row[4],
            )
